//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Moonfish.Guerilla.Tags
{
    using Moonfish.Tags;
    using Moonfish.Model;
    using System.IO;
    using System.Collections.Generic;
    using System.Linq;
    
    [TagClassAttribute("deca")]
    public partial class DecalBlock : GuerillaBlock, IWriteQueueable
    {
        public Flags DecalFlags;
        public TypeEnum Type;
        public LayerEnum Layer;
        public short MaxOverlappingCount;
        [Moonfish.Tags.TagReferenceAttribute("deca")]
        public Moonfish.Tags.TagReference NextDecalInChain;
        public Moonfish.Model.Range Radius;
        public float RadiusOverlapRejection;
        public Moonfish.Tags.ColourR8G8B8 ColorLowerBounds;
        public Moonfish.Tags.ColourR8G8B8 ColorUpperBounds;
        public Moonfish.Model.Range Lifetime;
        public Moonfish.Model.Range DecayTime;
        private byte[] fieldpad = new byte[40];
        private byte[] fieldpad0 = new byte[2];
        private byte[] fieldpad1 = new byte[2];
        private byte[] fieldpad2 = new byte[2];
        private byte[] fieldpad3 = new byte[2];
        private byte[] fieldpad4 = new byte[20];
        [Moonfish.Tags.TagReferenceAttribute("bitm")]
        public Moonfish.Tags.TagReference Bitmap;
        private byte[] fieldpad5 = new byte[20];
        public float MaximumSpriteExtent;
        private byte[] fieldpad6 = new byte[4];
        public override int SerializedSize
        {
            get
            {
                return 172;
            }
        }
        public override int Alignment
        {
            get
            {
                return 4;
            }
        }
        public override System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> ReadFields(System.IO.BinaryReader binaryReader)
        {
            System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> pointerQueue = new System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer>(base.ReadFields(binaryReader));
            this.DecalFlags = ((Flags)(binaryReader.ReadInt16()));
            this.Type = ((TypeEnum)(binaryReader.ReadInt16()));
            this.Layer = ((LayerEnum)(binaryReader.ReadInt16()));
            this.MaxOverlappingCount = binaryReader.ReadInt16();
            this.NextDecalInChain = binaryReader.ReadTagReference();
            this.Radius = binaryReader.ReadRange();
            this.RadiusOverlapRejection = binaryReader.ReadSingle();
            this.ColorLowerBounds = binaryReader.ReadColorR8G8B8();
            this.ColorUpperBounds = binaryReader.ReadColorR8G8B8();
            this.Lifetime = binaryReader.ReadRange();
            this.DecayTime = binaryReader.ReadRange();
            this.fieldpad = binaryReader.ReadBytes(40);
            this.fieldpad0 = binaryReader.ReadBytes(2);
            this.fieldpad1 = binaryReader.ReadBytes(2);
            this.fieldpad2 = binaryReader.ReadBytes(2);
            this.fieldpad3 = binaryReader.ReadBytes(2);
            this.fieldpad4 = binaryReader.ReadBytes(20);
            this.Bitmap = binaryReader.ReadTagReference();
            this.fieldpad5 = binaryReader.ReadBytes(20);
            this.MaximumSpriteExtent = binaryReader.ReadSingle();
            this.fieldpad6 = binaryReader.ReadBytes(4);
            return pointerQueue;
        }
        public override void ReadInstances(System.IO.BinaryReader binaryReader, System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> pointerQueue)
        {
            base.ReadInstances(binaryReader, pointerQueue);
        }
        public override void QueueWrites(Moonfish.Guerilla.QueueableBinaryWriter queueableBinaryWriter)
        {
            base.QueueWrites(queueableBinaryWriter);
        }
        public override void Write_(Moonfish.Guerilla.QueueableBinaryWriter queueableBinaryWriter)
        {
            base.Write_(queueableBinaryWriter);
            queueableBinaryWriter.Write(((short)(this.DecalFlags)));
            queueableBinaryWriter.Write(((short)(this.Type)));
            queueableBinaryWriter.Write(((short)(this.Layer)));
            queueableBinaryWriter.Write(this.MaxOverlappingCount);
            queueableBinaryWriter.Write(this.NextDecalInChain);
            queueableBinaryWriter.Write(this.Radius);
            queueableBinaryWriter.Write(this.RadiusOverlapRejection);
            queueableBinaryWriter.Write(this.ColorLowerBounds);
            queueableBinaryWriter.Write(this.ColorUpperBounds);
            queueableBinaryWriter.Write(this.Lifetime);
            queueableBinaryWriter.Write(this.DecayTime);
            queueableBinaryWriter.Write(this.fieldpad);
            queueableBinaryWriter.Write(this.fieldpad0);
            queueableBinaryWriter.Write(this.fieldpad1);
            queueableBinaryWriter.Write(this.fieldpad2);
            queueableBinaryWriter.Write(this.fieldpad3);
            queueableBinaryWriter.Write(this.fieldpad4);
            queueableBinaryWriter.Write(this.Bitmap);
            queueableBinaryWriter.Write(this.fieldpad5);
            queueableBinaryWriter.Write(this.MaximumSpriteExtent);
            queueableBinaryWriter.Write(this.fieldpad6);
        }
        /// <summary>
        /// There are several "layers" which decals can be placed into, these layers are drawn in a specific order relative to the shader layers and each layer has its own specific blending mode. In general, the decal bitmap's alpha channel will be used as an opacity mask if it exists.
        /// </summary>
        [System.FlagsAttribute()]
        public enum Flags : short
        {
            None = 0,
            /// <summary>
            ///  LIT ALPHA-BLEND PRELIGHT: Decals in this layer are lit by the lightmap but are "faded out" by dynamic lights. What this means is that dynamic lights hitting them will cause them to disappear, sort of. This layer is rendered immediately before lightmap shadows (and before dynamic lights).
            /// 
            /// 
            /// </summary>
            GeometryInheritedByNextDecalInChain = 1,
            /// <summary>
            ///  LIT ALPHA-BLEND: Decals in this layer are lit by the lightmap but are NOT lit by dynamic lights. What this means is that if the decal exists in an area that has dark lightmapping but bright dynamic lighting, the decal will appear dark. This layer is rendered immediately after dynamic lights, and all subsequent decal layers are rendered after this one in order.
            /// 
            /// 
            /// </summary>
            InterpolateColorInHsv = 2,
            /// <summary>
            ///  DOUBLE MULTIPLY: Decals in this layer will double-multiply the color in the framebuffer. Gray pixels in the decal bitmap will be transparent (black darkens, white brightens). The decal color in the tag does NOT do anything!!
            /// 
            /// 
            /// </summary>
            moreColors = 4,
            /// <summary>
            ///  MULTIPLY: Decals in this layer will multiply the color in the framebuffer. White pixels in the decal bitmap will be transparent. The decal color (in the decal tag) does NOT do anything!!
            /// 
            /// 
            /// </summary>
            NoRandomRotation = 8,
            /// <summary>
            ///  MAX: Decals in this layer will perform a component-wise max operation on the framebuffer, replacing color values with whichever is higher. Black pixels in the decal bitmap will be transparent.
            /// 
            /// 
            /// </summary>
            UNUSED = 16,
            /// <summary>
            ///  ADD: Decals in this layer will perform an addition operation on the framebuffer, replacing color values with the sum of the two. Black pixels in the decal bitmap will be transparent.
            /// 
            /// 
            /// </summary>
            SAPIENSnapToAxis = 32,
            /// <summary>
            ///  ERROR: Decals in this layer will render bright red and show through geometry!
            /// 
            /// A compound decal is a chain of decals which are instantiated simultaneously. Compound decals are created by referencing another decal tag in the 'next_decal_in_chain' field below. Do not attempt to create a circularly linked decal chain, i.e. A->B->C->A! This will cause problems and probably hang the game. Also, do not reference a decal from an effect if it is not the head of the chain; for example an effect should not instantiate decal B if the chain was A->B->C. Compound decals can have seperate bitmaps, etc., and can be drawn in seperate layers. In addition, we used to have the ability for each decal in the chain can either inherit its parent's radius, rotation, color, etc. - or it can randomly choose its own. This behavior was controlled by the 'geometry_inherited_by_next_decal_in_chain' flag, below but it's currently broken.
            /// </summary>
            SAPIENIncrementalCounter = 64,
            UNUSED0 = 128,
            PreserveAspect = 256,
            UNUSED1 = 512,
        }
        public enum TypeEnum : short
        {
            Scratch = 0,
            Splatter = 1,
            Burn = 2,
            PaintedSign = 3,
        }
        public enum LayerEnum : short
        {
            LitAlphablendPrelight = 0,
            LitAlphablend = 1,
            DoubleMultiply = 2,
            Multiply = 3,
            Max = 4,
            Add = 5,
            Error = 6,
        }
    }
}
namespace Moonfish.Tags
{
    
    public partial struct TagClass
    {
        public static TagClass Deca = ((TagClass)("deca"));
    }
}
