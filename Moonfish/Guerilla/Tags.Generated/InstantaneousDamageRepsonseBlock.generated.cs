//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Moonfish.Guerilla.Tags
{
    using JetBrains.Annotations;
    using Moonfish.Tags;
    using Moonfish.Model;
    using Moonfish.Guerilla;
    using System.IO;
    using System.Collections.Generic;
    using System.Linq;
    
    [JetBrains.Annotations.UsedImplicitlyAttribute(ImplicitUseTargetFlags.WithMembers)]
    [TagBlockOriginalNameAttribute("instantaneous_damage_repsonse_block")]
    public partial class InstantaneousDamageRepsonseBlock : GuerillaBlock, IWriteDeferrable
    {
        public ResponseTypeEnum ResponseType;
        public ConstraintDamageTypeEnum ConstraintDamageType;
        public Flags InstantaneousDamageRepsonseFlags;
        public float DamageThreshold;
        [Moonfish.Tags.TagReferenceAttribute("effe")]
        public Moonfish.Tags.TagReference TransitionEffect;
        public InstantaneousResponseDamageEffectStructBlock DamageEffect = new InstantaneousResponseDamageEffectStructBlock();
        public Moonfish.Tags.StringIdent Region;
        public NewStateEnum NewState;
        public short RuntimeRegionIndex;
        public Moonfish.Tags.StringIdent EffectMarkerName;
        public InstantaneousResponseDamageEffectMarkerStructBlock DamageEffectMarker = new InstantaneousResponseDamageEffectMarkerStructBlock();
        /// <summary>
        /// If desired, you can specify a delay until the response fires.This delay is pre-empted if another timed response for the same section fires.The delay effect plays while the timer is counting down
        /// </summary>
        public float ResponseDelay;
        [Moonfish.Tags.TagReferenceAttribute("effe")]
        public Moonfish.Tags.TagReference DelayEffect;
        public Moonfish.Tags.StringIdent DelayEffectMarkerName;
        /// <summary>
        /// - a response can destroy a single constraint by naming it explicitly.
        ///- alternatively it can randomly destroy a single constraint from a specified group if the "destroy one group constraint" flag is set
        ///- also it can destroy all constraints in a specified group if the "destroy all group constraints" flag is set
        /// </summary>
        public Moonfish.Tags.StringIdent ConstraintgroupName;
        public Moonfish.Tags.StringIdent EjectingSeatLabel;
        /// <summary>
        /// 0.0 always fires, 1.0 never fires
        /// </summary>
        public float SkipFraction;
        /// <summary>
        /// when this response fires, any children objects created at the supplied marker name will be destroyed
        /// </summary>
        public Moonfish.Tags.StringIdent DestroyedChildObjectMarkerName;
        /// <summary>
        /// scale on total damage section vitality
        /// </summary>
        public float TotalDamageThreshold;
        public override int SerializedSize
        {
            get
            {
                return 80;
            }
        }
        public override int Alignment
        {
            get
            {
                return 4;
            }
        }
        public override System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> ReadFields(Moonfish.Guerilla.BlamBinaryReader binaryReader)
        {
            System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> pointerQueue = new System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer>(base.ReadFields(binaryReader));
            this.ResponseType = ((ResponseTypeEnum)(binaryReader.ReadInt16()));
            this.ConstraintDamageType = ((ConstraintDamageTypeEnum)(binaryReader.ReadInt16()));
            this.InstantaneousDamageRepsonseFlags = ((Flags)(binaryReader.ReadInt32()));
            this.DamageThreshold = binaryReader.ReadSingle();
            this.TransitionEffect = binaryReader.ReadTagReference();
            pointerQueue = new System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer>(pointerQueue.Concat(this.DamageEffect.ReadFields(binaryReader)));
            this.Region = binaryReader.ReadStringIdent();
            this.NewState = ((NewStateEnum)(binaryReader.ReadInt16()));
            this.RuntimeRegionIndex = binaryReader.ReadInt16();
            this.EffectMarkerName = binaryReader.ReadStringIdent();
            pointerQueue = new System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer>(pointerQueue.Concat(this.DamageEffectMarker.ReadFields(binaryReader)));
            this.ResponseDelay = binaryReader.ReadSingle();
            this.DelayEffect = binaryReader.ReadTagReference();
            this.DelayEffectMarkerName = binaryReader.ReadStringIdent();
            this.ConstraintgroupName = binaryReader.ReadStringIdent();
            this.EjectingSeatLabel = binaryReader.ReadStringIdent();
            this.SkipFraction = binaryReader.ReadSingle();
            this.DestroyedChildObjectMarkerName = binaryReader.ReadStringIdent();
            this.TotalDamageThreshold = binaryReader.ReadSingle();
            return pointerQueue;
        }
        public override void ReadInstances(Moonfish.Guerilla.BlamBinaryReader binaryReader, System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> pointerQueue)
        {
            base.ReadInstances(binaryReader, pointerQueue);
            this.DamageEffect.ReadInstances(binaryReader, pointerQueue);
            this.DamageEffectMarker.ReadInstances(binaryReader, pointerQueue);
        }
        public override void DeferReferences(Moonfish.Guerilla.LinearBinaryWriter writer)
        {
            base.DeferReferences(writer);
            this.DamageEffect.DeferReferences(writer);
            this.DamageEffectMarker.DeferReferences(writer);
        }
        public override void Write(Moonfish.Guerilla.LinearBinaryWriter writer)
        {
            base.Write(writer);
            writer.Write(((short)(this.ResponseType)));
            writer.Write(((short)(this.ConstraintDamageType)));
            writer.Write(((int)(this.InstantaneousDamageRepsonseFlags)));
            writer.Write(this.DamageThreshold);
            writer.Write(this.TransitionEffect);
            this.DamageEffect.Write(writer);
            writer.Write(this.Region);
            writer.Write(((short)(this.NewState)));
            writer.Write(this.RuntimeRegionIndex);
            writer.Write(this.EffectMarkerName);
            this.DamageEffectMarker.Write(writer);
            writer.Write(this.ResponseDelay);
            writer.Write(this.DelayEffect);
            writer.Write(this.DelayEffectMarkerName);
            writer.Write(this.ConstraintgroupName);
            writer.Write(this.EjectingSeatLabel);
            writer.Write(this.SkipFraction);
            writer.Write(this.DestroyedChildObjectMarkerName);
            writer.Write(this.TotalDamageThreshold);
        }
        public enum ResponseTypeEnum : short
        {
            ReceivesAllDamage = 0,
            ReceivesAreaEffectDamage = 1,
            ReceivesLocalDamage = 2,
        }
        /// <summary>
        /// if you specify a constraint group name (see lower section of this block)
        ///  you can specify a constraint damage
        /// </summary>
        public enum ConstraintDamageTypeEnum : short
        {
            /// <summary>
            ///  loosening a constraint takes it out of the rigid state - activates it
            /// 
            /// </summary>
            None = 0,
            /// <summary>
            ///  destroying a constraint sets the attached body free
            /// </summary>
            DestroyOneOfGroup = 1,
            DestroyEntireGroup = 2,
            LoosenOneOfGroup = 3,
            LoosenEntireGroup = 4,
        }
        /// <summary>
        /// kills object: when the response fires the object dies regardless of its current health
        /// </summary>
        [System.FlagsAttribute()]
        public enum Flags : int
        {
            None = 0,
            /// <summary>
            ///  inhibits <x>: from halo 1 - disallows basic behaviors for a unit
            /// 
            /// </summary>
            KillsObject = 1,
            /// <summary>
            ///  forces drop weapon: from halo 1 - makes the unit drop its current weapon
            /// 
            /// </summary>
            InhibitsMeleeAttack = 2,
            /// <summary>
            ///  kills weapon <x> trigger: destroys the <x> trigger on the unit's current weapon
            /// 
            /// </summary>
            InhibitsWeaponAttack = 4,
            /// <summary>
            ///  destroys object: when the response fires the object is destroyed
            /// </summary>
            InhibitsWalking = 8,
            ForcesDropWeapon = 16,
            KillsWeaponPrimaryTrigger = 32,
            KillsWeaponSecondaryTrigger = 64,
            DestroysObject = 128,
            DamagesWeaponPrimaryTrigger = 256,
            DamagesWeaponSecondaryTrigger = 512,
            LightDamageLeftTurn = 1024,
            MajorDamageLeftTurn = 2048,
            LightDamageRightTurn = 4096,
            MajorDamageRightTurn = 8192,
            LightDamageEngine = 16384,
            MajorDamageEngine = 32768,
            KillsObjectnoPlayerSolo = 65536,
            CausesDetonation = 131072,
            DestroyAllGroupConstraints = 262144,
            KillsVariantObjects = 524288,
            ForceUnattachedEffects = 1048576,
            FiresUnderThreshold = 2097152,
            TriggersSpecialDeath = 4194304,
            OnlyOnSpecialDeath = 8388608,
            OnlyNOTOnSpecialDeath = 16777216,
        }
        public enum NewStateEnum : short
        {
            Default = 0,
            MinorDamage = 1,
            MediumDamage = 2,
            MajorDamage = 3,
            Destroyed = 4,
        }
    }
}
