//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Moonfish.Guerilla.Tags
{
    using JetBrains.Annotations;
    using Moonfish.Tags;
    using Moonfish.Model;
    using System.IO;
    using System.Collections.Generic;
    using System.Linq;
    
    [JetBrains.Annotations.UsedImplicitlyAttribute(ImplicitUseTargetFlags.WithMembers)]
    [TagClassAttribute("ligh")]
    [TagBlockOriginalNameAttribute("light_block")]
    public partial class LightBlock : GuerillaBlock, IWriteDeferrable
    {
        public Flags LightFlags;
        public TypeEnum Type;
        private byte[] fieldpad = new byte[2];
        public Moonfish.Model.Range SizeModifer;
        public float ShadowQualityBias;
        public ShadowTapBiasEnum ShadowTapBias;
        private byte[] fieldpad0 = new byte[2];
        /// <summary>
        /// default shape parameters for spherical lights
        /// </summary>
        public float Radius;
        public float SpecularRadius;
        /// <summary>
        /// default shape parameters for frustum lights (orthogonal, projective or pyramid types)
        /// </summary>
        public float NearWidth;
        public float HeightStretch;
        public float FieldOfView;
        public float FalloffDistance;
        public float CutoffDistance;
        public InterpolationFlags LightInterpolationFlags;
        public Moonfish.Model.Range BloomBounds;
        public Moonfish.Tags.ColourR8G8B8 SpecularLowerBound;
        public Moonfish.Tags.ColourR8G8B8 SpecularUpperBound;
        public Moonfish.Tags.ColourR8G8B8 DiffuseLowerBound;
        public Moonfish.Tags.ColourR8G8B8 DiffuseUpperBound;
        public Moonfish.Model.Range BrightnessBounds;
        /// <summary>
        /// the gel map tints the light's illumination per-pixel
        /// </summary>
        [Moonfish.Tags.TagReferenceAttribute("bitm")]
        public Moonfish.Tags.TagReference GelMap;
        public SpecularMaskEnum SpecularMask;
        private byte[] fieldpad1 = new byte[2];
        private byte[] fieldpad2 = new byte[4];
        public FalloffFunctionEnum FalloffFunction;
        public DiffuseContrastEnum DiffuseContrast;
        public SpecularContrastEnum SpecularContrast;
        public FalloffGeometryEnum FalloffGeometry;
        /// <summary>
        /// optional lens flare and light volume associated with this light
        /// </summary>
        [Moonfish.Tags.TagReferenceAttribute("lens")]
        public Moonfish.Tags.TagReference LensFlare;
        public float BoundingRadius;
        [Moonfish.Tags.TagReferenceAttribute("MGS2")]
        public Moonfish.Tags.TagReference LightVolume;
        public DefaultLightmapSettingEnum DefaultLightmapSetting;
        private byte[] fieldpad3 = new byte[2];
        public float LightmapHalfLife;
        public float LightmapLightScale;
        /// <summary>
        /// if the light is created by an effect, it will animate itself as follows
        /// </summary>
        public float Duration;
        private byte[] fieldpad4 = new byte[2];
        public LightFalloffFunctionEnum LightLightFalloffFunction;
        public IlluminationFadeEnum IlluminationFade;
        public ShadowFadeEnum ShadowFade;
        public SpecularFadeEnum SpecularFade;
        private byte[] fieldpad5 = new byte[2];
        public LightFlags0 LightLightFlags0;
        public LightBrightnessAnimationBlock[] BrightnessAnimation = new LightBrightnessAnimationBlock[0];
        public LightColorAnimationBlock[] ColorAnimation = new LightColorAnimationBlock[0];
        public LightGelAnimationBlock[] GelAnimation = new LightGelAnimationBlock[0];
        /// <summary>
        /// EMPTY STRING
        /// </summary>
        [Moonfish.Tags.TagReferenceAttribute("shad")]
        public Moonfish.Tags.TagReference Shader;
        public override int SerializedSize
        {
            get
            {
                return 228;
            }
        }
        public override int Alignment
        {
            get
            {
                return 4;
            }
        }
        public override System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> ReadFields(Moonfish.Guerilla.BlamBinaryReader binaryReader)
        {
            System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> pointerQueue = new System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer>(base.ReadFields(binaryReader));
            this.LightFlags = ((Flags)(binaryReader.ReadInt32()));
            this.Type = ((TypeEnum)(binaryReader.ReadInt16()));
            this.fieldpad = binaryReader.ReadBytes(2);
            this.SizeModifer = binaryReader.ReadRange();
            this.ShadowQualityBias = binaryReader.ReadSingle();
            this.ShadowTapBias = ((ShadowTapBiasEnum)(binaryReader.ReadInt16()));
            this.fieldpad0 = binaryReader.ReadBytes(2);
            this.Radius = binaryReader.ReadSingle();
            this.SpecularRadius = binaryReader.ReadSingle();
            this.NearWidth = binaryReader.ReadSingle();
            this.HeightStretch = binaryReader.ReadSingle();
            this.FieldOfView = binaryReader.ReadSingle();
            this.FalloffDistance = binaryReader.ReadSingle();
            this.CutoffDistance = binaryReader.ReadSingle();
            this.LightInterpolationFlags = ((InterpolationFlags)(binaryReader.ReadInt32()));
            this.BloomBounds = binaryReader.ReadRange();
            this.SpecularLowerBound = binaryReader.ReadColourR8G8B8();
            this.SpecularUpperBound = binaryReader.ReadColourR8G8B8();
            this.DiffuseLowerBound = binaryReader.ReadColourR8G8B8();
            this.DiffuseUpperBound = binaryReader.ReadColourR8G8B8();
            this.BrightnessBounds = binaryReader.ReadRange();
            this.GelMap = binaryReader.ReadTagReference();
            this.SpecularMask = ((SpecularMaskEnum)(binaryReader.ReadInt16()));
            this.fieldpad1 = binaryReader.ReadBytes(2);
            this.fieldpad2 = binaryReader.ReadBytes(4);
            this.FalloffFunction = ((FalloffFunctionEnum)(binaryReader.ReadInt16()));
            this.DiffuseContrast = ((DiffuseContrastEnum)(binaryReader.ReadInt16()));
            this.SpecularContrast = ((SpecularContrastEnum)(binaryReader.ReadInt16()));
            this.FalloffGeometry = ((FalloffGeometryEnum)(binaryReader.ReadInt16()));
            this.LensFlare = binaryReader.ReadTagReference();
            this.BoundingRadius = binaryReader.ReadSingle();
            this.LightVolume = binaryReader.ReadTagReference();
            this.DefaultLightmapSetting = ((DefaultLightmapSettingEnum)(binaryReader.ReadInt16()));
            this.fieldpad3 = binaryReader.ReadBytes(2);
            this.LightmapHalfLife = binaryReader.ReadSingle();
            this.LightmapLightScale = binaryReader.ReadSingle();
            this.Duration = binaryReader.ReadSingle();
            this.fieldpad4 = binaryReader.ReadBytes(2);
            this.LightLightFalloffFunction = ((LightFalloffFunctionEnum)(binaryReader.ReadInt16()));
            this.IlluminationFade = ((IlluminationFadeEnum)(binaryReader.ReadInt16()));
            this.ShadowFade = ((ShadowFadeEnum)(binaryReader.ReadInt16()));
            this.SpecularFade = ((SpecularFadeEnum)(binaryReader.ReadInt16()));
            this.fieldpad5 = binaryReader.ReadBytes(2);
            this.LightLightFlags0 = ((LightFlags0)(binaryReader.ReadInt32()));
            pointerQueue.Enqueue(binaryReader.ReadBlamPointer(8));
            pointerQueue.Enqueue(binaryReader.ReadBlamPointer(8));
            pointerQueue.Enqueue(binaryReader.ReadBlamPointer(16));
            this.Shader = binaryReader.ReadTagReference();
            return pointerQueue;
        }
        public override void ReadInstances(Moonfish.Guerilla.BlamBinaryReader binaryReader, System.Collections.Generic.Queue<Moonfish.Tags.BlamPointer> pointerQueue)
        {
            base.ReadInstances(binaryReader, pointerQueue);
            this.BrightnessAnimation = base.ReadBlockArrayData<LightBrightnessAnimationBlock>(binaryReader, pointerQueue.Dequeue());
            this.ColorAnimation = base.ReadBlockArrayData<LightColorAnimationBlock>(binaryReader, pointerQueue.Dequeue());
            this.GelAnimation = base.ReadBlockArrayData<LightGelAnimationBlock>(binaryReader, pointerQueue.Dequeue());
        }
        public override void DeferReferences(Moonfish.Guerilla.LinearBinaryWriter queueableBinaryWriter)
        {
            base.DeferReferences(queueableBinaryWriter);
            queueableBinaryWriter.Defer(this.BrightnessAnimation);
            queueableBinaryWriter.Defer(this.ColorAnimation);
            queueableBinaryWriter.Defer(this.GelAnimation);
        }
        public override void Write(Moonfish.Guerilla.LinearBinaryWriter queueableBinaryWriter)
        {
            base.Write(queueableBinaryWriter);
            queueableBinaryWriter.Write(((int)(this.LightFlags)));
            queueableBinaryWriter.Write(((short)(this.Type)));
            queueableBinaryWriter.Write(this.fieldpad);
            queueableBinaryWriter.Write(this.SizeModifer);
            queueableBinaryWriter.Write(this.ShadowQualityBias);
            queueableBinaryWriter.Write(((short)(this.ShadowTapBias)));
            queueableBinaryWriter.Write(this.fieldpad0);
            queueableBinaryWriter.Write(this.Radius);
            queueableBinaryWriter.Write(this.SpecularRadius);
            queueableBinaryWriter.Write(this.NearWidth);
            queueableBinaryWriter.Write(this.HeightStretch);
            queueableBinaryWriter.Write(this.FieldOfView);
            queueableBinaryWriter.Write(this.FalloffDistance);
            queueableBinaryWriter.Write(this.CutoffDistance);
            queueableBinaryWriter.Write(((int)(this.LightInterpolationFlags)));
            queueableBinaryWriter.Write(this.BloomBounds);
            queueableBinaryWriter.Write(this.SpecularLowerBound);
            queueableBinaryWriter.Write(this.SpecularUpperBound);
            queueableBinaryWriter.Write(this.DiffuseLowerBound);
            queueableBinaryWriter.Write(this.DiffuseUpperBound);
            queueableBinaryWriter.Write(this.BrightnessBounds);
            queueableBinaryWriter.Write(this.GelMap);
            queueableBinaryWriter.Write(((short)(this.SpecularMask)));
            queueableBinaryWriter.Write(this.fieldpad1);
            queueableBinaryWriter.Write(this.fieldpad2);
            queueableBinaryWriter.Write(((short)(this.FalloffFunction)));
            queueableBinaryWriter.Write(((short)(this.DiffuseContrast)));
            queueableBinaryWriter.Write(((short)(this.SpecularContrast)));
            queueableBinaryWriter.Write(((short)(this.FalloffGeometry)));
            queueableBinaryWriter.Write(this.LensFlare);
            queueableBinaryWriter.Write(this.BoundingRadius);
            queueableBinaryWriter.Write(this.LightVolume);
            queueableBinaryWriter.Write(((short)(this.DefaultLightmapSetting)));
            queueableBinaryWriter.Write(this.fieldpad3);
            queueableBinaryWriter.Write(this.LightmapHalfLife);
            queueableBinaryWriter.Write(this.LightmapLightScale);
            queueableBinaryWriter.Write(this.Duration);
            queueableBinaryWriter.Write(this.fieldpad4);
            queueableBinaryWriter.Write(((short)(this.LightLightFalloffFunction)));
            queueableBinaryWriter.Write(((short)(this.IlluminationFade)));
            queueableBinaryWriter.Write(((short)(this.ShadowFade)));
            queueableBinaryWriter.Write(((short)(this.SpecularFade)));
            queueableBinaryWriter.Write(this.fieldpad5);
            queueableBinaryWriter.Write(((int)(this.LightLightFlags0)));
            queueableBinaryWriter.WritePointer(this.BrightnessAnimation);
            queueableBinaryWriter.WritePointer(this.ColorAnimation);
            queueableBinaryWriter.WritePointer(this.GelAnimation);
            queueableBinaryWriter.Write(this.Shader);
        }
        [System.FlagsAttribute()]
        public enum Flags : int
        {
            None = 0,
            NoIlluminationdontCastAnyPerpixelDynamicLight = 1,
            NoSpeculardontCastAnySpecularHighlights = 2,
            ForceCastEnvironmentShadowsThroughPortals = 4,
            NoShadowdontCastAnyStencilShadows = 8,
            ForceFrustumVisibilityOnSmallLight = 16,
            OnlyRenderInFirstPerson = 32,
            OnlyRenderInThirdPerson = 64,
            DontFadeWhenInvisibledontFadeOutThisLightWhenUnderActivecamouflage = 128,
            MultiplayerOverridedontTurnOffInMultiplayer = 256,
            AnimatedGel = 512,
            OnlyInDynamicEnvmaponlyDrawThisLightInDynamicReflectionMaps = 1024,
            IgnoreParentObjectdontIlluminateOrShadowTheSingleObjectWeAreAttachedTo = 2048,
            DontShadowParentdontShadowTheObjectWeAreAttachedTo = 4096,
            IgnoreAllParentsdontIlluminateOrShadowAllTheWayUpToOurParentObject = 8192,
            MarchMilestoneHackdontClickThisUnlessYouKnowWhatYoureDoing = 16384,
            ForceLightInsideWorldeveryUpdateWillPushLightBackInsideTheWorld = 32768,
            EnvironmentDoesntCastStencilShadowsenvironmentInThisLightWillNotCastStencilShadows = 65536,
            ObjectsDontCastStencilShadowsobjectsInThisLightWillNotCastStencilShadows = 131072,
            FirstPersonFromCamera = 262144,
            TextureCameraGel = 524288,
            LightFramerateKiller = 1048576,
            AllowedInSplitScreen = 2097152,
            OnlyOnParentBipeds = 4194304,
        }
        /// <summary>
        /// overall shape of the light
        /// </summary>
        public enum TypeEnum : short
        {
            Sphere = 0,
            Orthogonal = 1,
            Projective = 2,
            Pyramid = 3,
        }
        public enum ShadowTapBiasEnum : short
        {
            _3Tap = 0,
            UNUSED = 1,
            _1Tap = 2,
        }
        /// <summary>
        /// EMPTY STRING
        /// </summary>
        [System.FlagsAttribute()]
        public enum InterpolationFlags : int
        {
            None = 0,
            BlendInHsvblendsColorsInHsvRatherThanRgbSpace = 1,
            moreColorsblendsColorsThroughMoreHuesgoesTheLongWayAroundTheColorWheel = 2,
        }
        public enum SpecularMaskEnum : short
        {
            Default = 0,
            NonenoMask = 1,
            GelAlpha = 2,
            GelColor = 3,
        }
        /// <summary>
        /// EMPTY STRING
        /// </summary>
        public enum FalloffFunctionEnum : short
        {
            Default = 0,
            Narrow = 1,
            Broad = 2,
            VeryBroad = 3,
        }
        public enum DiffuseContrastEnum : short
        {
            Defaultlinear = 0,
            High = 1,
            Low = 2,
            VeryLow = 3,
        }
        public enum SpecularContrastEnum : short
        {
            Defaultone = 0,
            Highlinear = 1,
            Low = 2,
            VeryLow = 3,
        }
        public enum FalloffGeometryEnum : short
        {
            Default = 0,
            Directional = 1,
            Spherical = 2,
        }
        /// <summary>
        /// how the light affects the lightmaps (ignored for dynamic lights)
        /// </summary>
        public enum DefaultLightmapSettingEnum : short
        {
            DynamicOnly = 0,
            DynamicWithLightmaps = 1,
            LightmapsOnly = 2,
        }
        public enum LightFalloffFunctionEnum : short
        {
            Linear = 0,
            Late = 1,
            VeryLate = 2,
            Early = 3,
            VeryEarly = 4,
            Cosine = 5,
            Zero = 6,
            One = 7,
        }
        /// <summary>
        /// To fade the light's illumination and shadow casting abilities
        /// </summary>
        public enum IlluminationFadeEnum : short
        {
            FadeVeryFar = 0,
            FadeFar = 1,
            FadeMedium = 2,
            FadeClose = 3,
            FadeVeryClose = 4,
        }
        public enum ShadowFadeEnum : short
        {
            FadeVeryFar = 0,
            FadeFar = 1,
            FadeMedium = 2,
            FadeClose = 3,
            FadeVeryClose = 4,
        }
        public enum SpecularFadeEnum : short
        {
            FadeVeryFar = 0,
            FadeFar = 1,
            FadeMedium = 2,
            FadeClose = 3,
            FadeVeryClose = 4,
        }
        /// <summary>
        /// EMPTY STRING
        /// </summary>
        [System.FlagsAttribute()]
        public enum LightFlags0 : int
        {
            None = 0,
            Synchronized = 1,
        }
    }
}
namespace Moonfish.Tags
{
    
    public partial struct TagClass
    {
        public static TagClass Ligh = ((TagClass)("ligh"));
    }
}
